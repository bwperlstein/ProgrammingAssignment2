setinvert <- function(z) {
invert <- matrix(nrow = ncol(z), ncol = nrow(z))
i <- 1
while (i <= nrow(z)) {
invert[1:ncol(z),i] <- z[i,1:ncol(z)]
i <- i + 1
}
invert_x <<- invert
orig_x <<- z
return(invert)
}
getinvert <- function() {
invert_x
orig_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
browser()
if(!is.null(invert_x[1, 1])) {                ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
invert_x <- t$setinvert(r)              ## A. Create inverse matrix AND B.cache matrices
return(invert_x)
}
obj <- makeCacheMatrix(x)
res <- cacheSolve(obj)
orig_x
a
## Put comments here that give an overall description of what your
## functions do
## Get cached (built) inverse matrix; build inverse matrix nd cache,
## store in cahe
makeCacheMatrix <- function(y = matrix()) {
orig_x <<- matrix(data = y, nrow = nrow(y), ncol = ncol(y))
invert_cols <- nrow(y)
invert_rows <- ncol(y)
invert_x <<- matrix(nrow = invert_rows, ncol = invert_cols)
invert_x <<- NULL
set <- function(y) {
orig_x <<- y
invert_x <<- NULL
}
get <- function() {
browser()
return(orig_x)
}
setinvert <- function(z) {
invert <- matrix(nrow = ncol(z), ncol = nrow(z))
i <- 1
while (i <= nrow(z)) {
invert[1:ncol(z),i] <- z[i,1:ncol(z)]
i <- i + 1
}
invert_x <<- invert
orig_x <<- z
return(invert)
}
getinvert <- function() {
invert_x
orig_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
browser()
if(!is.null(invert_x[1, 1])) {                ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
invert_x <- t$setinvert(a)              ## A. Create inverse matrix AND B.cache matrices
return(invert_x)
}
obj <- makeCacheMatrix(x)
res <- cacheSolve(obj)
orig_x
res
res <- cacheSolve(obj)
x <- matrix(data = 21:1, nrow = 7, ncol = 3)
x
obj <- makeCacheMatrix(x)
res <- cacheSolve(obj)
res
x
## Put comments here that give an overall description of what your
## functions do
## Get cached (built) inverse matrix; build inverse matrix nd cache,
## store in cahe
makeCacheMatrix <- function(y = matrix()) {
orig_x <<- matrix(data = y, nrow = nrow(y), ncol = ncol(y))
invert_cols <- nrow(y)
invert_rows <- ncol(y)
invert_x <<- matrix(nrow = invert_rows, ncol = invert_cols)
invert_x <<- NULL
set <- function(y) {
orig_x <<- y
invert_x <<- NULL
}
get <- function() {
return(orig_x)
}
setinvert <- function(z) {
invert <- matrix(nrow = ncol(z), ncol = nrow(z))
i <- 1
while (i <= nrow(z)) {
invert[1:ncol(z),i] <- z[i,1:ncol(z)]
i <- i + 1
}
invert_x <<- invert
orig_x <<- z
return(invert)
}
getinvert <- function() {
invert_x
orig_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
invert_x <- t$setinvert(a)              ## A. Create inverse matrix AND B.cache matrices
return(invert_x)
}
obj <- makeCacheMatrix(x)
res
res <- cacheSolve(obj)
res
x <- matrix(data = rnorm(100), nrow = 20, ncol = 5)
x
obj <- makeCacheMatrix(x)
res <- cacheSolve(obj)
res
?solve
x
solve(x)
x <- matrix(data = 1:25, nrow = 5, ncol = 5)
x
solve(x)
x <- matrix(data = rnorm(25), nrow = 5, ncol = 5)
x
solve(x)
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrows(y))
invert_x <<- NULL
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
x <- matrix(data = 1:25, nrow = 5, ncol = 5)
obj <- makeCacheMatrix(x)
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrow(y))
invert_x <<- NULL
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
x
obj <- makeCacheMatrix(x)
res <- cacheSolve(obj)
?solve
cacheSolve(x)
x <- matrix(data = rnorm(25), nrow = 5)
x
cacheSolve(x)
debug(solve)
cacheSolve(x)
solve(x)
debug(cacheSolve)
obj <- makeCacheMatrix(x)
res <- cacheSolve(x)
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrow(y))
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrow(y))
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
obj <- makeCacheMatrix(x)
res <- cacheSolve(x)
debug(cacheSolve)
res <- cacheSolve(x)
debug t$getgetinvert
debug(t$getgetinvert)
debug(t$getgetinvert)
debug(getinvert)
res <- cacheSolve(obj)
res
x
invert_x
debug*(makeCacheMatrix())
debug*(makeCacheMatrix
obj <- makeCacheMatrix(x)
debug(makeCacheMatrix)
obj <- makeCacheMatrix(x)
invert_x
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrow(y), ncol = ncol(y))
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
debug(makeCacheMatrix)
obj <- makeCacheMatrix(x)
invert_x
res <- cacheSolve(obj)
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrow(y), ncol = ncol(y))
invert_x <<- NULL
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and return.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
debug(makeCacheMatrix)
obj <- makeCacheMatrix(x)
invert_x
res <- cacheSolve(obj)
## Put comments here that give an overall description of what your
## functions do
## Functions neeed to: a Get cached (built) inverse matrix or b. cache the inverse matrix
makeCacheMatrix <- function(y = matrix()) {
invert_x <<- matrix(nrow = nrow(y), ncol = ncol(y))
invert_x <<- NULL
set <- function(y) {                    ## Cache matrix and initialize inverse
x <<- y
invert_x <<- NULL
}
get <- function() {                     ## Get cached value of matrix
return(x)
}
setinvert <- function(z) {              ## Cache inverse matrix
invert_x <<- z
return(invert_x)
}
getinvert <- function() {               ## Get cached value of inverse matrix
invert_x
}
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## Write a short comment describing this function
## Return cached inverse matrix if available. Otherwise calculate inverse matrix and cache.
cacheSolve <- function(t, ...) {
t$getinvert()                           ## Retrieve cached values for matrices
a <- t$get()                            ## Retieve current matrix
if(!is.null(invert_x[1, 1])) {          ## if inverse calculated, do not recalc
message("Getting cached data")
return(invert_x)
}
b <- solve(a)                           ## Create inverse
invert_x <- t$setinvert(b)              ## A. Cache original and inverse matrices
return(invert_x)
}
debug(makeCacheMatrix)
obj <- makeCacheMatrix(x)
res <- cacheSolve(obj)
res
res <- cacheSolve(obj)
rm(ls())
rm(ls)
rm(list = ls())
x <- rnorm(20)
x
mean(x)
sd(x)
x <- rnorm(20, 0, 1)
x
mean(x)
sd(x)
x <- rnorm(20, 0, 2)
x
sd(x)
mean(x)
summary(x)
str(x)
rm(x)
x <- rnorm(10)
x
x <- rnorm(10, 20, 2)
x
x
summary(x)
str(x)
getwd()
setwd("/R/Gas")
setwd("./R/Gas")
fn
library(data,table)
library(data.table)
library(xlsx)
library(xlsx)
?read.xlsx
ls()
dir()
fn <- "Natural Gas Acquisition Program.xlsx"
blah <- read.xlsx(fn, sheetIndex = 1, rowIndex = 1:2, header = FALSE)
library(xlsxjars)
library(rJava)
blah <- read.xlsx(fn, sheetIndex = 1, rowIndex = 1:2, header = FALSE)
blah <- read.xlsx(fn, sheetIndex = 1)
library(readxl)
install.packages("readxl")
?read.excel
?read_excel
?read.xl
?read.xl
blah <- read_excel(fn, sheetIndex = 1)
library(devtools)
blah <- read_excel(fn, sheetIndex = 1)
install.packages("libxls")
libraru(libxls)
library(libxls)
blah <- read.xlsx(fn, sheetIndex = 1)
blah <- read_xlsx(fn, sheetIndex = 1)
blah <- readxl::read_xlsx(fn, sheetIndex = 1)
library(readxl)
install.packages("readxl")
library(readxl)
blah <- read_xlsx(fn, sheetIndex = 1)
?read_excel
blah <- read_xlsx(fn)
blah <- read_excel(fn)
fn
getwd()
